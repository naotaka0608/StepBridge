"""STEP to OBJ conversion logic using Open Cascade."""

from pathlib import Path
from dataclasses import dataclass

from OCP.STEPControl import STEPControl_Reader
from OCP.IFSelect import IFSelect_RetDone
from OCP.BRepMesh import BRepMesh_IncrementalMesh
from OCP.TopExp import TopExp_Explorer
from OCP.TopAbs import TopAbs_FACE
from OCP.TopLoc import TopLoc_Location
from OCP.BRep import BRep_Tool
from OCP.TopoDS import TopoDS


@dataclass
class ConversionResult:
    """Result of a conversion operation."""
    success: bool
    message: str
    output_path: Path | None = None
    vertex_count: int = 0
    face_count: int = 0


def read_step_file(file_path: Path) -> object:
    """Read a STEP file and return the shape."""
    reader = STEPControl_Reader()
    status = reader.ReadFile(str(file_path))

    if status != IFSelect_RetDone:
        raise ValueError(f"Failed to read STEP file: {file_path}")

    reader.TransferRoots()
    shape = reader.OneShape()
    return shape


def tessellate_shape(shape, linear_deflection: float = 0.1, angular_deflection: float = 0.5):
    """Tessellate a shape into a mesh."""
    mesh = BRepMesh_IncrementalMesh(shape, linear_deflection, False, angular_deflection, True)
    mesh.Perform()
    return shape


def extract_mesh_data(shape) -> tuple[list[tuple[float, float, float]], list[tuple[int, int, int]], list[tuple[float, float, float]]]:
    """Extract vertices, faces, and normals from a tessellated shape."""
    vertices = []
    faces = []
    normals = []
    vertex_index_map = {}
    current_index = 0

    explorer = TopExp_Explorer(shape, TopAbs_FACE)

    while explorer.More():
        face = TopoDS.Face_s(explorer.Current())
        location = TopLoc_Location()
        triangulation = BRep_Tool.Triangulation_s(face, location)

        if triangulation is not None:
            transform = location.Transformation()

            # Get vertices for this face
            face_vertex_start = current_index
            for i in range(1, triangulation.NbNodes() + 1):
                node = triangulation.Node(i)
                transformed = node.Transformed(transform)
                vertex = (transformed.X(), transformed.Y(), transformed.Z())
                vertices.append(vertex)
                vertex_index_map[(id(face), i)] = current_index
                current_index += 1

            # Get triangles for this face
            for i in range(1, triangulation.NbTriangles() + 1):
                triangle = triangulation.Triangle(i)
                n1, n2, n3 = triangle.Get()

                # Calculate face normal
                v1 = vertices[face_vertex_start + n1 - 1]
                v2 = vertices[face_vertex_start + n2 - 1]
                v3 = vertices[face_vertex_start + n3 - 1]

                edge1 = (v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2])
                edge2 = (v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2])

                normal = (
                    edge1[1] * edge2[2] - edge1[2] * edge2[1],
                    edge1[2] * edge2[0] - edge1[0] * edge2[2],
                    edge1[0] * edge2[1] - edge1[1] * edge2[0]
                )

                # Normalize
                length = (normal[0]**2 + normal[1]**2 + normal[2]**2) ** 0.5
                if length > 0:
                    normal = (normal[0]/length, normal[1]/length, normal[2]/length)
                else:
                    normal = (0.0, 0.0, 1.0)

                normals.append(normal)

                # OBJ indices are 1-based
                faces.append((
                    face_vertex_start + n1,
                    face_vertex_start + n2,
                    face_vertex_start + n3
                ))

        explorer.Next()

    return vertices, faces, normals


def write_obj_file(
    output_path: Path,
    vertices: list[tuple[float, float, float]],
    faces: list[tuple[int, int, int]],
    normals: list[tuple[float, float, float]]
) -> None:
    """Write mesh data to an OBJ file."""
    with open(output_path, 'w') as f:
        f.write("# Generated by STEP to OBJ Converter\n")
        f.write(f"# Vertices: {len(vertices)}\n")
        f.write(f"# Faces: {len(faces)}\n\n")

        # Write vertices
        for v in vertices:
            f.write(f"v {v[0]:.6f} {v[1]:.6f} {v[2]:.6f}\n")

        f.write("\n")

        # Write normals
        for n in normals:
            f.write(f"vn {n[0]:.6f} {n[1]:.6f} {n[2]:.6f}\n")

        f.write("\n")

        # Write faces (OBJ is 1-indexed)
        for i, face in enumerate(faces):
            normal_idx = i + 1
            f.write(f"f {face[0]}//{normal_idx} {face[1]}//{normal_idx} {face[2]}//{normal_idx}\n")


def convert_step_to_obj(
    input_path: Path,
    output_path: Path,
    linear_deflection: float = 0.1,
    angular_deflection: float = 0.5
) -> ConversionResult:
    """Convert a STEP file to OBJ format."""
    try:
        # Read STEP file
        print(f"[1/4] Reading STEP file: {input_path}")
        shape = read_step_file(input_path)
        print("[1/4] Done reading STEP file")

        # Tessellate
        print("[2/4] Tessellating...")
        tessellate_shape(shape, linear_deflection, angular_deflection)
        print("[2/4] Done tessellating")

        # Extract mesh data
        print("[3/4] Extracting mesh data...")
        vertices, faces, normals = extract_mesh_data(shape)
        print(f"[3/4] Done: {len(vertices)} vertices, {len(faces)} faces")

        if not vertices or not faces:
            return ConversionResult(
                success=False,
                message="No geometry found in STEP file"
            )

        # Write OBJ file
        print(f"[4/4] Writing OBJ file: {output_path}")
        write_obj_file(output_path, vertices, faces, normals)
        print("[4/4] Done writing OBJ file")

        return ConversionResult(
            success=True,
            message="Conversion completed successfully",
            output_path=output_path,
            vertex_count=len(vertices),
            face_count=len(faces)
        )

    except Exception as e:
        import traceback
        traceback.print_exc()
        return ConversionResult(
            success=False,
            message=f"Conversion failed: {str(e)}"
        )
